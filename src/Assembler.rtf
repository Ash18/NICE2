{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2057\deflangfe2057{\fonttbl{\f0\fmodern\fprq1\fcharset0 Courier New;}}
{\*\generator Riched20 6.3.9600}{\*\mmathPr\mdispDef1\mwrapIndent1440 }\viewkind4\uc1 
\pard\widctlpar\b\f0\fs24\lang1033 NICE Assembler \par
\ul\b0 Version 2.1, October 2015\par
\ulnone\par
A simple assembler for writing \b NICE\b0  programs has been included with the simulator. This document describes in brief the assembler operations. \par
\par
An assembly language program is processed one line at a time. A line of the program may be one of:\par
\par
a. an assembler directive (or \lquote pseudo-operation\rquote ), as described below\par
b. an instruction of the \b NICE\b0  processor, coded in assembly language\par
c. 8-bit binary data (a byte) to be loaded into memory \par
d. comment line, which has characters \lquote //\rquote  in the first two columns\par
\par
Comments may also be included \lquote in-line\rquote , i.e. all text to the right of \lquote //\rquote  in a line is neglected.\par
\ul\par
Notation\ulnone :\par
\par
All text included in an assembly language program is \ul case-insensitive\ulnone , e.g. \lquote ADD\rquote  and \lquote add\rquote  have the same meaning.\par
\par
Numerical values included in the program must be in \ul hexadecimal\ulnone  (base 16) or \ul decimal\ulnone  (base 10), except that the .bin pseudo-operation switches the assembler to accept 8-bit binary data.\par
 \par
Because of this restriction of hex and decimal format, a simple constant such as 1 must be written as x1, x01, #1 or #01. The hex constant x0032, for example, has decimal value 3*16+2 = #50.  \par
\par
For convenience, however, register references are made using decimal numbers, i.e. the processor registers are numbered R0 to R15 -- NOT R0 to RF.\par
\ul\par
Assembler directives\ulnone :\par
\par
.start <hex address>\par
\par
Specifies the starting address for execution of the program, once the program is assembled and loaded into memory. Use of a label is allowed in place of <hex address> provided that the label is already defined in an earlier line (i.e. is not a forward reference).\par
\par
.orig <hex address>\par
\par
Specifies the location from which successive bytes from the output of the assembly program will be loaded into memory.\par
\par
.bin\par
\par
Specifies that 8-bit binary data is being supplied in successive lines of the program. The only assembler directive allowed in this binary mode is .asm.  \par
\par
.asm\par
\par
Specifies that assembly language instructions of the \b NICE\b0  processor are being supplied in successive lines of the program.\par
\par
.clear\par
\par
Specifies that the 4 kilobytes of simulator memory should be cleared to all zero bits.\par
\par
This directive should be viewed as a \lquote loader\rquote  option \endash  i.e. whether loader should clear memory before loading into it the output generated by subsequent assembly language instructions. \par
\par
Normally this directive would appear at the start of the assembly language program. If output of two or more separate assembly language programs is to be loaded into memory one after the other, then naturally this directive should only appear with the first program.\par
\par
.end\par
\par
Specifies the end of the assembly language program. This directive is optional (since \lquote end of file\rquote  also indicates program end), but may be used for readability.\par
\par
\ul Byte or word mode:\par
\ulnone\par
Byte or word mode of operation (see the textbook) must be specified explicitly \endash  i.e. there is no default provided in the assembler. Thus \lquote MOV R1 R2\rquote  is illegal; it should be either \lquote MOV B R1 R2\rquote  or \lquote MOV W R1 R2\rquote  (in upper or lower case).\par
\par
\ul Addressing modes\ulnone :\par
\par
The addressing modes described in the textbook are supported. \par
\par
Register addressing - using e.g. r11, R0, R15, etc. \endash  where the register number is in decimal, from 0 to 15.  \par
\par
Direct addressing - e.g. memory address x200, or a label representing a memory location. This addressing mode occurs in load and store instructions, and in conditional or unconditional transfers of control.\par
\par
Indirect addressing \endash  a register has the memory address needed. This mode occurs in load and store instructions, e.g. load w [r8] r9.\par
\par
Indexed addressing - in load and store instructions, e.g. load b x200[r8] r9. The base address (e.g. x200) occupies 19 bits in the machine instruction, and is padded with 5 zero bits on the right at the time of execution of instruction. Assembly language program must contain therefore the 24-bit base address in which the right-most 5 bits are \lquote 00000\rquote . Thus the programmed base address must be a multiple of x20.\par
\par
Immediate addressing \endash  in arithmetic, logic and move instructions. The immediate constant is 20 bits in size, and is unsigned. The format may be hexadecimal or decimal (see above).\par
\par
\ul Labels\ulnone : \par
\par
Labels may be used with \b NICE\b0  instructions, so that the instructions can be used as targets of transfer of control. \par
\par
In a one-pass assembler, care needs to be taken to support forward references \endash  i.e. use of a label in a transfer of control \ul before\ulnone  it is defined. The present assembler performs \lquote back-patching\rquote  of forward reference labels. \par
\par
For example, suppose the instruction JMP XXX occurs in the program, but label XXX has not yet been defined. The assembler will leave zeros in place of the JMP target. In the last phase of assembly, once XXX has been defined, the actual address of XXX will be \lquote back-patched\rquote  into the JMP instruction. \par
\par
When such \lquote back-patching occurs\rquote , the assembler generates appropriate informative messages for the user.\par
\par
\ul\b NICE\b0  Instruction set\ulnone :\par
\par
For ease of reference, the \b NICE\b0  instruction set is summarized below. For more details and explanation, please refer to the textbook (Chapters 4 & 5, Table 5.1).\par
\par
------------------------------------------------------------\par
|\b Instr-\b0  | \b Modifier\b0   | \b First operand\b0             | \b Second\b0      |\par
|\b uction\b0  |           |                          | \b operand\b0     |\par
------------------------------------------------------------\par
|LOAD,  | byte/word | memory address: direct,  | register   |\par
|STORE  |           | Indirect, indexed        |            |\par
------------------------------------------------------------\par
|MOV    | b/w       | source: register or      | register   |\par
|       |           | immediate                |            |\par
------------------------------------------------------------\par
|IN,    |no modifier| port number              | register   |\par
|OUT    |always byte|                          |            |\par
|\tab    |mode\tab\tab |\tab\tab\tab\tab\tab   |\tab\tab\tab |\tab\par
------------------------------------------------------------\par
|ADD,   | b/w       | source: register or      | register   |\par
|SUB    |           | immediate                |            |\par
|AND,   |           |                          |            |\par
|OR,    |           |                          |            |\par
|XOR,   |           |                          |            |\par
|NOT,   |           |                          |            |\par
|COMP   |           |                          |            |\par
------------------------------------------------------------\par
|SHIFT  | b/w,      | register                 | count      |\par
|       | r/l,      |                          |            |\par
|       | c/nc      |                          |            |\par
------------------------------------------------------------\par
|JMP    |           | destination              |            |\par
|J\i cond\i0   |           | address                  |            |\par
|J\i flag\i0   |           |                          |            |\par
|J\i nflag\i0  |           |                          |            |\par
|CALL   |           |                          |            |\par
------------------------------------------------------------\par
|RET,   |           |                          |            |\par
|HALT   |           |                          |            |\par
------------------------------------------------------------\par
\par
            Instruction set of \b NICE\b0  processor\par
\ul\par
Assembly language instruction format\ulnone :\par
\b\par
\b0 In assembly language, \b NICE\b0  instructions are typed in the following format:\par
\par
[\ul label\ulnone :] \ul opcode\ulnone  \ul modifier(s)\ulnone  \ul operand(s)\ulnone\par
\par
Here \ul label\ulnone  is optional. Opcode, modifier(s) and operand(s) are specified as shown in the textbook. Commas and square brackets may be used to increase readability of the assembly language programs, but they are not required. Tokens of the instructions must be separated by spaces or commas. Redundant commas and brackets are tolerated.\par
\par
Thus the following pairs show equivalent instructions:\par
\par
\lquote MOV B R1 R2\rquote   &  \lquote MOV B R1,R2\rquote\par
\par
\lquote LOAD W x200[R1] R2\rquote   &  \lquote LOAD W x200 R1 R2\rquote\par
\par
Sample assembly language programs included with the simulator provide many examples.\par
 \par
\par
\par
\par
}
 